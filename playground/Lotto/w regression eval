import numpy as np
import pandas as pd
import tensorflow as tf
from sklearn.preprocessing import MinMaxScaler, LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import matplotlib.pyplot as plt
import os
import random

# Set random seed for reproducibility
seed = 42
os.environ['PYTHONHASHSEED'] = str(seed)
random.seed(seed)
np.random.seed(seed)
tf.random.set_seed(seed)

class DateAndPMIncorporatedLotteryPredictor:
    def __init__(self):
        self.model = None
        self.scaler = MinMaxScaler()
        self.date_scaler = MinMaxScaler()
        self.pm_encoder = LabelEncoder()

    def load_data(self, csv_path, number_column='lottery_number', date_column='date', pm_column='prime_minister'):
        """Loads and preprocesses the dataset."""
        data = pd.read_csv(csv_path)
        data[date_column] = pd.to_datetime(data[date_column])
        data['day_of_year'] = data[date_column].dt.dayofyear
        data['year'] = data[date_column].dt.year
        data[pm_column] = self.pm_encoder.fit_transform(data[pm_column])

        features = data[[number_column, 'day_of_year', 'year', pm_column]].values
        scaled_features = self.scaler.fit_transform(features)

        X = scaled_features[:, 1:]  # Features: day_of_year, year, pm
        y = scaled_features[:, 0]   # Target: lottery_number

        return train_test_split(X, y, test_size=0.2, random_state=42)

    def build_model(self):
        """Builds a simple neural network model."""
        self.model = tf.keras.Sequential([
            tf.keras.layers.Dense(64, activation='relu', input_shape=(3,)),
            tf.keras.layers.Dense(32, activation='relu'),
            tf.keras.layers.Dense(1)
        ])
        self.model.compile(optimizer='adam', loss='mse')

    def train(self, X_train, y_train, epochs=50, batch_size=32):
        """Trains the model."""
        self.model.fit(X_train, y_train, epochs=epochs, batch_size=batch_size, verbose=1)

    def evaluate(self, X_test, y_test):
        """Evaluates the model and computes regression metrics."""
        predictions = self.model.predict(X_test).flatten()

        # Reverse scaling for meaningful metrics
        y_test_rescaled = self.scaler.inverse_transform(np.c_[y_test, np.zeros((y_test.shape[0], 3))])[:, 0]
        predictions_rescaled = self.scaler.inverse_transform(np.c_[predictions, np.zeros((predictions.shape[0], 3))])[:, 0]

        # Compute metrics
        r2 = r2_score(y_test_rescaled, predictions_rescaled)
        mae = mean_absolute_error(y_test_rescaled, predictions_rescaled)
        mse = mean_squared_error(y_test_rescaled, predictions_rescaled)
        rmse = np.sqrt(mse)

        print("Regression Metrics:")
        print(f"RÂ²: {r2:.4f}")
        print(f"MAE: {mae:.4f}")
        print(f"MSE: {mse:.4f}")
        print(f"RMSE: {rmse:.4f}")

        return r2, mae, mse, rmse

# Example usage
if __name__ == "__main__":
    predictor = DateAndPMIncorporatedLotteryPredictor()
    
    # Load and split data
    X_train, X_test, y_train, y_test = predictor.load_data("lottery_data w PM.csv")

    # Build, train, and evaluate the model
    predictor.build_model()
    predictor.train(X_train, y_train, epochs=10)
    predictor.evaluate(X_test, y_test)

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Treatment of Reflex Syncope</title>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand&display=swap" rel="stylesheet">

<style>
    /*
    body::-webkit-scrollbar{
    display: none;}*/

    * {margin: 0;max-width: 1920px;
        font-family: 'Quicksand', sans-serif;};

    .block {width: 100%;min-height: 100vh};
    .canvas {border: solid 1vmax red;}
    /*color*/
    .darkBlue {background-color: #082b3a}
    .indigo {background-color: #1c444c}
    .yellow {background-color: #f2cf49}
    .orange {background-color: #E36E53}
    .cyan {background-color: #3F9DA4;}

    #title {
        color: pink;
        font-size: 6vmax;text-align: center;
        font-family: 'Quicksand', sans-serif;
        letter-spacing: 1px;
    }
    #subTitle {
        color: #e2fcff;
        text-align: center;
        font-size: 2.5vmax;
        letter-spacing: 5px;
        font-family: 'Quicksand', sans-serif;
    }
    #logoPanel {
        padding-top: 5vmax;text-align: center;
        font-family: 'Quicksand', sans-serif;
        color: #888;font-size: 1.5vmax;
    }
    .topic {
        font-family: 'Quicksand', sans-serif;
        color: #e2fcff;font-size: 3vmax;
        text-align: center;padding: 1vmax;
    }
    .ref, .ref a {
        padding: 2vmax;
        font-family: 'Quicksand', sans-serif;
        color: #666;font-size: 1.4vmax;text-align: center;
    }
    #brainCord {
        display: flex;
        align-content: center;align-self: center;text-align: center;
        color: #e2fcff;font-size: 2vmax;text-align: center;
        font-family: 'Quicksand', sans-serif;
    }
    #brainCord div {align-items: center;align-self: center;}
    .bCordImg {align-self: center;}
    #benignS {display: flex;}
    #benignS div {flex: 50%;color: #e2fcff;font-size: 2vmax;}

    #movieBar {display: flex;padding: 7vmax 1vmax 2vmax 1vmax;}
    #textBlk {flex:0.25;color: #e2fcff;font-size: 5vmax;padding: 1vw;
        align-self: center;text-align: center;}
    #movieBlk {flex:0.75;align-self: center;text-align: center;}
    #defRefSyn {color: #e2fcff;font-size: 2vmax;padding-top: 3vh;visibility: hidden;
        text-align:left;line-height: 110%;border-top: #3F9DA4 solid 0.1vmin;}
    #qRefSyn {padding-bottom: 1vh;color:#f2cf49};
       
    #controlBar {font-size: 2.2vmax;color: #232323;
    width: fit-content;margin-left: auto;margin-right: auto;}
    #controlBar span {cursor: pointer;
        background-color: #ddd;padding:0 2vmin;border-radius: 0.2vw;}

    #endPage {padding: 3vmax;background-color: #555;text-align: center;
        color: #ddd;
    }
    #endPage a {color: #ddd;}
    
    @media only screen and (max-width: 820px) {
        #benignS {flex-wrap: wrap;}
        #movieBar {flex-wrap: wrap;}
    }

</style>

</head>
<body>
    <div class="block" style="background:radial-gradient(ellipse at bottom, #1b2735 0%, #082b3a 100%);
    height: 100vh;">
        <canvas class="canvas">
        </canvas>
        <div id="subTitle">
            Management of
        </div>
        <div id="title">
            REFLEX SYNCOPE
        </div>
        <div id="logoPanel">
            <img src="boxGreyRect.png" style="width: 2vmax;">
            <span style="vertical-align: 5px;">heartRhythmBox.com</span>
        </div>
    </div>

    <!--syncope vs SCD -- cerebral blood flow-->
    <div class="block" style="background-color: #232323;min-height: 100vh;">
        <div class="topic" style="padding-top:3vmax;">
            The thin line between Syncope and Sudden Cardiac Death
        </div>
        <canvas class="canvas"></canvas>
        <div id="brainCord">
            <div>
                <img src="media\label.png" class="bCordImg">
            </div>
            <div>A<br>
                <img src="media\brainCordA.png" class="bCordImg">
            </div>
            <div>B<br>
                <img src="media\brainCordB.png" class="bCordImg">
            </div>
            <div>C<br>
                <img src="media\brainCordC.png" class="bCordImg">
            </div>
            <div>D<br>
                <img src="media\brainCordD.png"  class="bCordImg">
            </div>
         </div>
        <div class="ref">
            <a href="https://doi.org/10.3389/fcvm.2020.00036" target="_blank">
                Front Cardiovasc Med 2020.
            </a>
        </div>
    </div>

    <!--benign syncope-->
    <div class="block" style="background-color: #232323;min-height: 100vh;padding-top: 5vmax;">
        <div id="benignS">
            <div style="font-size: 5vmax;text-align: center;line-height: 110%;border-radius: 2vmax;
            padding: 10vmax 3vmax;background-color: #f2cf49;color: #082b3a;">
                <span style="font-weight: 900;">Reflex Syncope</span>
                <br>
                has a benign prognosis.
            </div>
            <div style="background-color: #3F9DA4;color: #1b2735;border-radius: 2vmax;
            text-align: center;padding: 10vmax 3vmax;align-content: center;">
                <span style="border-bottom: #082b3a solid 0.1vmax;padding-top: 1vmax;">
                    HR (95%CI) for all-cause mortality</span>
                <br>
                <div class="orange" style="font-size: 3vmax;color:#232323;
                font-weight: 600;margin-top: 2vmax;vertical-align: middle;padding: 1vw;
                border-radius: 1vw;">
                    Cardiac Syncope: 1.43
                    <span style="font-size: 2vmax;font-weight: 900;">
                    (1.25-1.64)</span>
                </div>
                <div class="indigo" style="font-size: 3vmax;color:#e2fcff;font-weight: 900;
                margin-top: 1vmax;vertical-align: middle;padding: 1vw;border-radius: 1vw;">
                    Reflex Syncope: 1.17 
                <span style="font-size: 2vmax;;font-weight: 400;">
                    (0.95-1.44)
                </span>
                </div>
                <a href="https://www.nejm.org/doi/full/10.1056/nejmoa012407" target="_blank" 
                class="ref">
                    NEJM 2002.
                </a>
            </div>
        </div>
    </div>

    <!--what is reflex syncope-->
    <div class="block indigo">
        <div id="movieBar">
            <div id="textBlk">
                <div id="qRefSyn">
                What is Reflex Syncope?
                </div>
                <div id="defRefSyn">
                    - Syncope due to failure of neural reflex to control BP.<br>
                    - Including vasovagal syncope, situational syncope, and carotid sinus syndrome.
                </div>
            </div>
            <div id="movieBlk">
                <video id="sully" controls style="width: 100%;">
                    <source src="media\SullySyncope.mp4" type="video/mp4">
                </video>
            </div>
        </div>
        <div class="ref" style="padding-bottom: 2vmax;color: #888;">
            <a href="https://doi.org/10.1111/jce.13266" target="_blank" style="color: #888;">
                J Cardiovasc Electrophysiol. 2017 Sep;28(9):1088-1097.
            </a> and
            <a href="https://www.pixar.com/feature-films/monsters-inc" style="color: #888;">
                When Sully Thought Boo Dies. Monsters, Inc; Pixar.
            </a>
        </div>

    </div>
    

    <!--sym/parasym interplay-->
    <div class="block" style="background: radial-gradient(ellipse at bottom, #1b2735 0%, #082b3a 100%);padding: 2vmax 0;
    min-height: 100vh;">
        <div class="topic" style="padding-top: 5vmax;">The Interplay between sym- & parasympathetic system</div>
        <canvas class="canvas">
        </canvas>
    </div>

    <!--ref Syn animation-->
    <div class="block" style="background: radial-gradient(ellipse at bottom, #1b2735 0%, #082b3a 100%);padding: 2vmax 0;
    min-height: 100vh;">
        <div class="topic" style="padding-top: 1vmax;color: pink;font-size: 4vmax;">
            REFLEX SYNCOPE
        </div>
        <div id="controlBar" style="width: fit-content;margin-left: auto;margin-right: auto;">
           <span title="play" onclick="canvas3(3,'1')">&#9655;</span>&nbsp;&nbsp;
           <span title="reload" onclick="canvas3(3,'0')">&#10227;</span>
        </div>
        <canvas class="canvas">
        </canvas>
    </div>

<!--end page-->
<div id="endPage" class="block">
    <div id="about">
        <div style="max-width: 600px;margin-left: auto;margin-right: auto;text-align: center;">
            <div style="padding-bottom: 2vh;">
                <a href="#top" style="text-decoration:none;color: white;">
                    &uarr;&nbsp;<b>Top</b> of the page</a>
            </div>  
            <div style="padding-bottom: 2vh;">
                    <a href="https://heartRhythmBox.com/" target="_blank" 
                    style="text-decoration:none;color: white;">
                        <img src="boxGrey.png" style="width: 37px;">
                    </a> &nbsp;&nbsp;
                    <a href="https://www.youtube.com/channel/UCb9nCPfRKR_F2ppLaYZC43w/featured" 
                    target="_blank" style="text-decoration:none;color: white;">
                        <img src="youTube.png" style="width: 38px;">
                    </a>
            </div>
            <div style="font-size: 13px;padding: 2vh 1vw;border-top: #ddd 0.1vmax solid;color: #eee;text-align: justify;">
                Heart Rhythm Box is a collection of web-paged style presentations in clinical cardiac electrophysiology topics.
                The page is created mainly for educational purpose. 
                We believe that presentations should be more interactive and easily accessible. 
                No need to register or download. You can access everything at your fingertips.
            </div>
            <div style="font-size: 13px;padding: 2vh 1vw;border-top: #ddd 0.1vmax solid;color: #ddd;
            text-align: center;font-weight: 700;">
                &copy;&nbsp;&nbsp;CODING OF A KIND<br>
                <span style="font-weight: 400;">
                design to your style &middot; write to your need</span>
            </div>
    
    
    </div>
</div>

<script>

//detect orientation change
window.addEventListener("orientationchange", function() {
            location.reload();
        });

//nav
window.addEventListener("keydown", function(event) {
    event.preventDefault();
    if (event.keyCode===40) {
      next(1)
    }
    if (event.keyCode===38) {
      next(-1)
    }
})

const block = document.getElementsByClassName('block');
const canvas = document.getElementsByClassName('canvas')
const vw = Math.round(window.innerWidth/100);
const vh = Math.round(window.innerHeight/100);
const vmin = Math.min(vw,vh)
canvas0(0);
canvas1(1);
canvas2(2);
canvas3(3,-1)

/*syncope vs SCD*/
function canvas1(key){
    const ctx = canvas[key].getContext("2d");
    const scale = window.devicePixelRatio;
    const centerX = 50*vw;const centerY = 12*vh;
    const radius = 35*vmin;
    const cHeight = centerY + radius + 2*vh;
    canvas[key].style.width = window.innerWidth + 'px';
    canvas[key].style.height = cHeight + 'px';
    canvas[key].width = Math.floor(window.innerWidth * scale*1);
    canvas[key].height = Math.floor(cHeight * scale*1);
    ctx.scale(scale*1,scale*1);

    document.getElementById('brainCord').style.marginLeft = centerX - 3*2*radius/4 + 'px';
    const img = document.getElementsByClassName('bCordImg');
    for (let index = 0; index < img.length; index++) {
        img[index].style.width = 2*radius/4 + 'px';        
    }

    const angle1 = 45/180 * Math.PI;
    const angle2 = 25/180 * Math.PI;
    const h = Math.sin(angle1)*radius

    //A to D
    ctx.beginPath();
    ctx.moveTo(centerX - Math.cos(angle2)*radius,centerY);
    ctx.lineTo(centerX + Math.cos(angle2)*radius,centerY);
    ctx.moveTo(centerX - Math.cos(angle2)*radius,centerY + h);
    ctx.lineTo(centerX + Math.cos(angle2)*radius,centerY + h);
    ctx.strokeStyle = '#eee';ctx.lineWidth = 3;
    ctx.stroke();

    ctx.strokeStyle = '#555';ctx.lineWidth =1;
    ctx.moveTo(centerX - Math.cos(angle2)*radius,centerY + 0.25*h);
    ctx.lineTo(centerX + Math.cos(angle2)*radius,centerY + 0.25*h);

    ctx.moveTo(centerX - Math.cos(angle2)*radius,centerY + 0.5*h);
    ctx.lineTo(centerX + Math.cos(angle2)*radius,centerY + 0.5*h);

    ctx.moveTo(centerX - Math.cos(angle2)*radius,centerY + 0.75*h);
    ctx.lineTo(centerX + Math.cos(angle2)*radius,centerY + 0.75*h);

    ctx.stroke();
    ctx.closePath();


    ctx.beginPath();
    ctx.moveTo(centerX - Math.cos(angle2)*radius,centerY);
    ctx.lineTo(centerX,centerY + Math.sin(angle1)*radius);
    ctx.lineTo(centerX,centerY + Math.sin(angle2)*radius);
    ctx.lineTo(centerX - Math.cos(angle1)*radius,centerY);

    var grd = ctx.createLinearGradient(centerX - Math.cos(angle2)*radius,centerY,
    centerX,centerY + Math.sin(angle2)*radius);
    grd.addColorStop(0.25,'green');
    grd.addColorStop(0.5,'yellow');
    grd.addColorStop(0.75,'orange');
    grd.addColorStop(1,'red');
    ctx.fillStyle = grd;
    ctx.fill();
    ctx.closePath();

    ctx.beginPath();
    ctx.moveTo(centerX + Math.cos(angle2)*radius,centerY);
    ctx.lineTo(centerX,centerY+Math.sin(angle1)*radius);
    ctx.lineTo(centerX,centerY+ Math.sin(angle2)*radius);
    ctx.lineTo(centerX + Math.cos(angle1)*radius,centerY);

    var grd = ctx.createLinearGradient(centerX + Math.cos(angle2)*radius,centerY,
    centerX,centerY + Math.sin(angle2)*radius);
    grd.addColorStop(0.25,'green');
    grd.addColorStop(0.5,'yellow');
    grd.addColorStop(0.75,'orange');
    grd.addColorStop(1,'red');
    ctx.fillStyle = grd;
    ctx.fill();
    ctx.closePath();

    //label
    ctx.beginPath();
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.font = 1.5*vw + 'px Quicksand';
    ctx.fillText('Normal Level',centerX,centerY-0.5*vw);
    ctx.textBaseline = 'top';
    ctx.font = 1.5*vw + 'px Quicksand';
    ctx.fillText('Below Normal Level',centerX,centerY+0.5*vw);
    ctx.fillStyle='#ababab';ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.font = 1.8*vw + 'px Quicksand';
    ctx.fillText('A',centerX - Math.cos(angle2)*radius,centerY + 0.25*h);
    ctx.fillText('B',centerX - Math.cos(angle2)*radius,centerY + 0.5*h);
    ctx.fillText('C',centerX - Math.cos(angle2)*radius,centerY + 0.75*h);
    ctx.fillText('D',centerX - Math.cos(angle2)*radius,centerY + h);
    ctx.textAlign = 'right';
    ctx.fillText('Cerebral Blood Flow',centerX- Math.cos(angle2)*radius,centerY);

    //coma line
    ctx.moveTo(centerX,centerY+Math.sin(angle1)*radius);
    //ctx.arc(centerX,centerY+Math.sin(angle1)*radius,0.2*vw,0,2*Math.PI);
    ctx.lineTo(centerX + Math.cos(angle2)*radius,centerY+Math.sin(angle1)*radius);
    //ctx.arc(centerX + Math.cos(angle2)*radius,centerY+Math.sin(angle1)*radius,0.2*vw,0,2*Math.PI);
    ctx.moveTo(centerX + Math.cos(angle2)*radius,centerY+Math.sin(angle1)*radius);
    ctx.lineTo((centerX + Math.cos(angle2)*radius)-vw,centerY+Math.sin(angle1)*radius-vh);
    ctx.moveTo(centerX + Math.cos(angle2)*radius,centerY+Math.sin(angle1)*radius);
    ctx.lineTo((centerX + Math.cos(angle2)*radius)-vw,centerY+Math.sin(angle1)*radius+vh);
    ctx.lineWidth = 4;
    ctx.strokeStyle = 'red';ctx.fillStyle = 'red';
    ctx.stroke();ctx.fill();
    ctx.fillStyle='#ababab';ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.font = 1.8*vw + 'px Quicksand';
    ctx.fillText('Coma or Sudden Cardiac Death',centerX + Math.cos(angle2)*radius,
    centerY+Math.sin(angle1)*radius+vw);
    ctx.closePath();

    //syncope line
    ctx.beginPath();
    ctx.moveTo(centerX,centerY+Math.sin(angle1)*radius);
    //ctx.arc(centerX,centerY+Math.sin(angle1)*radius,0.2*vw,0,2*Math.PI);
    ctx.lineTo(centerX + Math.cos(angle2)*radius,centerY);
    //ctx.arc(centerX + Math.cos(angle2)*radius,centerY,0.2*vw,0,2*Math.PI);
    ctx.moveTo(centerX + Math.cos(angle2)*radius,centerY);
    ctx.lineTo(centerX + Math.cos(angle2)*radius - 0.5*vw ,centerY + 1.8*vh);
    ctx.moveTo(centerX + Math.cos(angle2)*radius,centerY);
    ctx.lineTo(centerX + Math.cos(angle2)*radius - 1.8*vh ,centerY - 0.5*vw);
    ctx.lineWidth = 4;
    ctx.strokeStyle = '#d1ffbd';ctx.fillStyle = '#d1ffbd';
    ctx.font = 2*vw + 'px Quicksand';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText('SYNCOPE',centerX + Math.cos(angle2)*radius,centerY-vw);
    ctx.stroke();ctx.fill();
    
}

/*sym parasym*/
function canvas2(key){
    const ctx = canvas[key].getContext("2d");
    const radius = 30*vmin;
    const centerX = 50*vw;
    const centerY = 10*vh + radius;
    const cHeight = centerY + radius + 5*vh;
    const scale = window.devicePixelRatio;
    canvas[key].style.width = window.innerWidth + 'px';
    canvas[key].style.height = cHeight + 'px';
    canvas[key].width = Math.floor(window.innerWidth * scale*1);
    canvas[key].height = Math.floor(cHeight * scale*1);
    ctx.scale(scale*1,scale*1);

    const min = 0.4;
    const max = 0.6;
    const maxStep = 20;
    var gap = 0;
    var left = min;
    var fwd = 0.01;
    var step = 0;

    var gd = 0;
    var fire = getFireGrd(key,centerX,centerY,radius,1);
    var ice = getIceGrd(key,centerX,centerY,radius,1);

    setInterval(() => {
        ctx.clearRect(0,0,100*vw,100*vh);
        var leftGd = ctx.createLinearGradient(centerX,centerY+radius,centerX,centerY-radius);
        majorLabel(key,centerX,centerY,radius,'#e2faff')
        drawLeft(key,centerX,centerY,radius, left-gap,fire);
        drawRight(key,centerX,centerY,radius,1-left-gap,ice);   
        left = left + fwd; 
        step++;
        gd = step/25;

        if (left>max){
            left=max;
        }
        if (left<min){
            left=min;
        }
        if (step>maxStep){
            step = 0;
            if (left>=max){fwd = -0.01;}
            if (left<=min){fwd = 0.01;}
        }
    }, 200);
}

function canvas0(){
    const ctx = canvas[0].getContext("2d");
    const radius = 5*vw;
    const centerX = 50*vw;
    const centerY = 25*vh;
    const cHeight = centerY + radius + 2*vh;
    const scale = window.devicePixelRatio;
    canvas[0].style.width = window.innerWidth + 'px';
    canvas[0].style.height = cHeight + 'px';
    canvas[0].width = Math.floor(window.innerWidth * scale*1);
    canvas[0].height = Math.floor(cHeight * scale*1);
    ctx.scale(scale*1,scale*1);

    //baseAnimation
    //0.45-0.55
    const min = 0.4;
    const max = 0.6;
    const maxStep = 20;
    var gap = 0;
    var left = min;
    var fwd = 0.01;
    var step = 0;

    var gd = 0;


    setInterval(() => {
        ctx.clearRect(0,0,100*vw,100*vh);
        var leftGd = ctx.createLinearGradient(centerX,centerY+radius,centerX,centerY-radius);
        leftGd.addColorStop(gd, '#1c444c');
        leftGd.addColorStop(1, '#3F9DA4')
        drawLeft(0,centerX,centerY,radius, left-gap,leftGd);
        drawRight(0,centerX,centerY,radius,1-left-gap,'#e2fcff');   
        left = left + fwd; 
        step++;
        gd = step/25;

        if (left>max){
            left=max;
        }
        if (left<min){
            left=min;
        }
        if (step>maxStep){
            step = 0;
            if (left>=max){fwd = -0.01;}
            if (left<=min){fwd = 0.01;}
        }
    }, 200);

}

var nav=0;
function canvas3(key,option){
    const ctx = canvas[key].getContext("2d");
    const radius = 30*vmin;
    const centerX = 50*vw;
    const centerY = 10*vh + radius;
    //const cHeight = centerY + radius + 5*vh;
    const scale = window.devicePixelRatio;
    canvas[key].style.width = window.innerWidth + 'px';
    canvas[key].style.height = window.innerHeight + 'px';
    canvas[key].width = Math.floor(window.innerWidth * scale*1);
    canvas[key].height = Math.floor(window.innerHeight * scale*1);
    ctx.scale(scale*1,scale*1);

    setTimeout(() => {
        dysAutonomia(0.38,0.55,0.4,1); 
    }, 1000);
    setTimeout(() => {
        trigger();
    }, 4000);
    /*
    if (option==-1){
        dysAutonomia(0.38,0.55,0.4,1); 
        majorLabel(key,centerX,centerY,radius,'#3f7eb3');
    }
    
    if (option==0){
        nav=0;
        dysAutonomia(0.38,0.55,0.4,1);
    }
    if (option==1){
        nav++;
        stepMove();
    }
*/
    function stepMove(){
        if (nav==1){
            trigger();
        }
        if (nav==2){
            paraSymOverLoad(1);
        }
        if (nav==3){
            pSymEffect('all');
        }
        if (nav==4){
            clearSyncope();
            nav=0;
        }
      
    }

    function dysAutonomia(maxL,maxR,minR,loop){
    //dysAutonomia(0.38,0.55,0.4,5);    
    var fire = getFireGrd(key,centerX,centerY,radius,1);
    var ice = getIceGrd(key,centerX,centerY,radius,1);

    //key,centerX,centerY,radius,ratio,color
    //step 0 -- together
    drawLeft(key,centerX,centerY,radius,0.5,fire);
    drawRight(key,centerX,centerY,radius,0.5,ice);

    //step 1 -- separated;
    var left = 0.5;var right = 0.5;
    var end = Math.max(0.5-maxL,0.5-maxR);
    var step1 = setInterval(() => {
        for (let index = 0; index <= end; index=index+0.01) {
        left = left - index;
        if (left<maxL){left=maxL};
        right = right + index;
        if (right>maxR){right=maxR}
        ctx.clearRect(0,0,100*vw,100*vh);
        majorLabel(key,centerX,centerY,radius,'#3f7eb3');
        drawLeft(key,centerX,centerY,radius,left,fire);
        drawRight(key,centerX,centerY,radius,right,ice);
      } 
    }, 200);
    clearInterval(step1);

    //step2
    //step2 -- animated ice
    var step = 0;var maxStep = 10+(maxR-minR)*10;var fwd = 0.01;
    var right = maxR+step;var left = maxL;
    var count = 0;
    var step2 = setInterval(function(){
        animateIce();count++;

        if (loop>0 && count>=(maxStep*loop)){
        clearInterval(step2);
    }
        },100)


    function animateIce(){
            ctx.clearRect(0,0,100*vw,100*vh);
            majorLabel(key,centerX,centerY,radius,'#3f7eb3');
            right = right + fwd;
            step++;
            if (right<minR){
                right = minR;left = left+0.01}
            if (right>maxR){
                right = maxR;left = left-0.01};
            if (step>maxStep){
                step = 0;
                if (right>=maxR){fwd = -0.01;}
                if (right<=minR){fwd = 0.01;}
            }
            drawLeft(key,centerX,centerY,radius,left,fire);
            drawRight(key,centerX,centerY,radius,right,ice);

    }
    }

    function trigger(color){
        const trgX = 10*vw;
        ctx.beginPath();
        ctx.font = 3.25*vw + 'px Quicksand';
        ctx.textAlign = 'left';ctx.textBaseline = 'bottom';
        if (color==null){
            color='#ddd'
        }
        ctx.fillStyle = color;
        ctx.fillText(" Trig",trgX - (radius/4),centerY);
        ctx.fillText("gers",trgX-2*vw,centerY + 2.75*vw);
        //bracket
        const topX = trgX - (radius/4) - 0.5*vw;
        const topY = centerY - 4*vw;
        const bottomX = topX;
        const bottomY = centerY + 3.25*vw + vh;
        bracket(topX,topY,bottomX,bottomY,'#ababab', 'left');
        bracket(topX + 11*vw,topY,topX + 11*vw,bottomY,'#ababab','right');
        arrow(topX + 12*vw,centerY,centerX- radius - 2*vw,centerY);

    //example of trigger
    }

    function bracket(x1,y1,x2,y2,color,side){
    const capWidth = 0.2*(y2-y1);
    if (side=='left'){
    //top
    ctx.beginPath();
    ctx.moveTo(x1+capWidth,y1);
    //ctx.lineTo(x1+vw,y1);
    ctx.arcTo(x1,y1,x1,y1+capWidth,capWidth);
    //ctx.lineTo(x2,y2);
    ctx.strokeStyle = color;
    ctx.stroke();
    ctx.closePath();
    //bottom
    ctx.beginPath();
    ctx.moveTo(x2+capWidth,y2);
    ctx.arcTo(x2,y2,x2,y2-capWidth,capWidth);
    ctx.stroke();
    ctx.closePath();
    }
    else {
        //top
        ctx.beginPath();
        ctx.moveTo(x1-capWidth,y1);
        ctx.arcTo(x1,y1,x1,y1+capWidth,capWidth);
        ctx.strokeStyle = color;
        ctx.stroke();
        ctx.closePath();
        //bottom
        ctx.beginPath();
        ctx.moveTo(x2-capWidth,y2);
        ctx.arcTo(x2,y2,x2,y2-capWidth,capWidth);
        ctx.stroke();
        ctx.closePath();
    }
}

    function arrow(x1,y1,x2,y2,color,side){
    //cal distance = sqRt (x2-x1)2 + (y2-y1)2
    const d = Math.sqrt(((x2-x1)*(x2-x1)+((y2-y1)*(y2-y1))));
    var arrow = 0.1*d;
    if (side=='left'){
        var head = -1
    } else {var head = 1}
    if (arrow<2*vw){arrow=2*vw}
    const angle = 30/180 * Math.PI ;
    ctx.beginPath();
    ctx.lineWidth = 2;
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    //arrowTop
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2-Math.cos(angle)*arrow*head,y2-Math.sin(angle)*arrow);
    //arrowBottom
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2-Math.cos(angle)*arrow*head,y2+Math.sin(angle)*arrow);
    ctx.stroke();
}

    function clearSyncope(){
        paraSymOverLoad('still');
        var trigHex = '#e2fcff';
        var syncHex = '#e2fcff';
        var left = 0.1;var right = 0.9;
        var fireColor = getFireGrd(key,centerX,centerY,radius,1);
        var iceColor = getIceGrd(key,centerX,centerY,radius,8);
        //const fireUp = 4;
        //const iceDown = 2;

        //fireBase 0.1 to 0.5
        for (let index = 0; index < 40; index++) {
            setTimeout(() => {
                ctx.clearRect(0,0,100*vw,100*vh);
                var opac = 1-(index/50);
                trigColor = toRGB(trigHex,opac);
                syncColor = toRGB(syncHex,opac);
                trigger(trigColor);
                syncopeText('text',syncColor);

                fireColor = getFireGrd(1+(index/10));
                iceColor = getIceGrd(8-(index/6));
                drawLeft(key,centerX,centerY,radius,fireColor);
                drawRight(key,centerX,centerY,radius,iceColor);  
                left = left+0.01;if (left>=0.5){left=0.5};
                right = right-0.01;if (right<=0.5){right=0.5};

                if (index==39){
                    //arrow
                    const topX = 10*vw - (radius/4) - 0.5*vw;
                    const aWidth = (centerX-radius)-(topX+12*vw);
                    ctx.clearRect(topX + 12*vw,centerY-2*vw,aWidth,5*vw);
                }
            }, 50*index);
        }
    }

    function toRGB(color,opacity){
        String(color);
        const hex = ['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f']
        var red1 = color[1];var red2 = color[2];
        red = hex.indexOf(red1)*16 + hex.indexOf(red2) ;
        var green1 = color[3];var green2 = color[4];
        green = hex.indexOf(green1) *16 + hex.indexOf(green2); 
        var blue1 = color[5];var blue2 = color[6];
        blue = hex.indexOf(blue1)*16 + hex.indexOf(blue2);
        String(red);String(green);String(blue)
        var rgbaColor = 'rgba(' +red +','+ green + ',' + blue + ',' + opacity+')';
        return rgbaColor;
    }

    function syncopeText(option,color){
        const fSize = 2.8*vw;
        const syncY = centerY+radius+2.5*fSize+vw;
        const syncTop = syncY-1.5*fSize-vw;
        const syncBottom = syncY+vw;
        const syncMid = 0.5*(syncBottom-syncTop) + syncTop;
        const arrowX = centerX + radius + 2*vw;
        const arrowWidth = 4*vw;  
        const x1 = arrowX+arrowWidth+vw;
        const midTextX = x1+fSize;
        const bottomTextY = centerY+2.2*fSize;
        const cap = Math.round((syncMid-bottomTextY)*0.2);
        //text
        if (option =='text'){
        ctx.beginPath();
        ctx.textBaseline = 'bottom';
        ctx.font =  1.5*fSize + 'px Arial';
        ctx.textAlign = 'center';
        if (color==null){
            color = '#e2fcff';
        }
        ctx.fillStyle = color;
        ctx.fillText ('SYNCOPE',centerX,syncY);
        ctx.fill();
        ctx.closePath();
        bracket(centerX-4.5*fSize-vw,syncTop,centerX-4.5*fSize-vw,syncBottom,'#e2fcff','left');
        bracket(centerX+4.5*fSize+vw,syncTop,centerX+4.5*fSize+vw,syncBottom,'#e2fcff','right');
        }

        if (option =='line'){
            ctx.beginPath();
            ctx.strokeStyle = '#ababab';
            ctx.moveTo(midTextX,bottomTextY+vw);
            ctx.lineTo(midTextX,syncMid-cap);
            ctx.moveTo(centerX+4.5*fSize+2*vw,syncMid);
            ctx.lineTo(midTextX-cap,syncMid);
            ctx.arcTo(midTextX,syncMid,midTextX,syncMid-cap,cap);
            ctx.stroke();
            arrow(midTextX-cap,syncMid,centerX+4.5*fSize+2*vw,syncMid,'#ababab','left');
            ctx.closePath();
        }
    }

    function pSymEffect(option){
        if (option=='all'){
        const arrowX = centerX + radius + 2*vw;
        const arrowWidth = 4*vw;    
        const fSize = 2.8*vw;
        arrow(arrowX,centerY,arrowX+arrowWidth,centerY,'#ababab');

        const x1 = arrowX+arrowWidth+vw;
        ctx.beginPath();
        ctx.textBaseline = 'bottom';
        ctx.font =  fSize + 'px Arial';
        ctx.textAlign = 'left';
        ctx.fillStyle = '#ddd';
        ctx.fillText('↓SV',x1+vw,centerY-1.1*fSize);
        ctx.fillText('↓HR',x1+vw,centerY);
        ctx.fillText('↓SVR',x1+vw,centerY+1.1*fSize);
        ctx.fillText('↓BP',x1+vw,centerY+2.2*fSize);
        ctx.fill();
        ctx.closePath();

        const syncY = centerY+radius+2.5*fSize+vw;
        const syncTop = syncY-1.5*fSize-vw;
        const syncBottom = syncY+vw;
        const syncMid = 0.5*(syncBottom-syncTop) + syncTop;
        //connecting line
        setTimeout(() => {
            syncopeText('line')
        }, 600);
        //syncope
        setTimeout(() => {
            syncopeText('text');    
        }, 1200);
        }

        if (option == 'effect'){
            const arrowX = centerX + radius + 2*vw;
            const arrowWidth = 4*vw;    
            const fSize = 2.8*vw;
            arrow(arrowX,centerY,arrowX+arrowWidth,centerY,'#ababab');

            const x1 = arrowX+arrowWidth+vw;
            ctx.beginPath();
            ctx.textBaseline = 'bottom';
            ctx.font =  fSize + 'px Arial';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#ddd';
            ctx.fillText('↓SV',x1+vw,centerY-1.1*fSize);
            ctx.fillText('↓HR',x1+vw,centerY);
            ctx.fillText('↓SVR',x1+vw,centerY+1.1*fSize);
            ctx.fillText('↓BP',x1+vw,centerY+2.2*fSize);
            ctx.fill();
            ctx.closePath();
        }

    }

//fireRatio and fireGrd
//iceRatio, starting grd and ending grd
    function iceUp(fire,fireGrd,ice,from,to){
    
    var fireColor = getFireGrd(fireGrd);
    var right = ice;
    
    for (let index = from; index <= to; index=index +0.5) {
        setTimeout(() => {
            var iceColor = getIceGrd(index);
            ctx.clearRect(0,0,100*vw,100*vh);
            trigger(0);
            drawLeft(fire,fireColor);
            drawRight(right,iceColor); 
            right = right + 0.02;
            if (right+fire>=1){right = 1-fire};
        }, 100*index);
    }

}

    function paraSymOverLoad(animate){
    var left = 0.26;var right = 0.55;
    var ice = 1;
    const coldLevel = 8;
    var fireColor = getFireGrd(key,centerX,centerY,radius,1);
    var iceColor = getIceGrd(key,centerX,centerY,radius,ice);
    const fireDown = 0.1;
    const step = 2*Math.ceil((right-fireDown)/0.02);
   
    if (animate ==1){
    for (let index = 0; index <step; index++) {
        setTimeout(() => {
            ice = ice + (coldLevel/step);
            if (ice>=coldLevel){ice = coldLevel}
            iceColor = getIceGrd(key,centerX,centerY,radius,ice);
            ctx.clearRect(0,0,100*vw,100*vh);
            trigger(iceColor);
            drawLeft(key,centerX,centerY,radius,left,fireColor);
            drawRight(key,centerX,centerY,radius,right,iceColor); 
            majorLabel(key,centerX,centerY,radius,'#32648f');
            right = right + 0.01;left = left-(left-fireDown)/step;
            if (left<=fireDown){left=fireDown}
            if (right+fireDown>=1){right = 1-fireDown};
        }, 50*index);
    }
    } else {
        for (let index = 0; index <step; index++) {

            ice = ice + (coldLevel/step);
            if (ice>=coldLevel){ice = coldLevel}
            iceColor = getIceGrd(key,centerX,centerY,radius,ice);
            ctx.clearRect(0,0,100*vw,100*vh);
            drawLeft(key,centerX,centerY,radius,left,fireColor);
            drawRight(key,centerX,centerY,radius,right,iceColor); 
            majorLabel(key,centerX,centerY,radius,'#32648f');
            right = right + 0.01;left = left-(left-fireDown)/step;
            if (left<=fireDown){left=fireDown}
            if (right+fireDown>=1){right = 1-fireDown};
        }
    }   
}



}


function drawLeft(key,centerX,centerY,radius,ratio,color){
    const ctx = canvas[key].getContext("2d");
    //arc left
    ctx.beginPath();
    ctx.arc(centerX,centerY+(radius*(1-ratio)),radius*ratio, 1.5*Math.PI, 0.5*Math.PI);
    ctx.arc(centerX,centerY, radius, 0.5 * Math.PI, 1.5 * Math.PI);
    ctx.arc(centerX,centerY-(radius*ratio),radius*(1-ratio), 1.5*Math.PI, 0.5*Math.PI,true);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.closePath();
}

function drawRight(key,centerX,centerY,radius,ratio,color){
    const ctx = canvas[key].getContext("2d");
    //arc right
    ctx.beginPath();
    ctx.arc(centerX,centerY-(radius*(1-ratio)),radius*ratio,0.5*Math.PI,1.5*Math.PI);
    ctx.arc(centerX,centerY,radius, 1.5*Math.PI,0.5*Math.PI);
    ctx.arc(centerX,centerY+(radius*ratio),radius*(1-ratio),0.5*Math.PI,1.5*Math.PI,true);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.closePath()
}

function getFireGrd(key,centerX,centerY,radius,hot){
    const ctx = canvas[key].getContext("2d");
    const fireColor = ['#801100','#b62203','#d73502','#fc6400','#ff7500','#FAC000'];
    const fire = ctx.createLinearGradient(centerX,centerY+radius,centerX,centerY-radius);
    for (let index = 0; index < fireColor.length; index++) {
        var hotFactor = (hot + index)/10;
        if (hotFactor>1){hotFactor =1}
        fire.addColorStop(hotFactor, fireColor[index]);
    }
    return fire;
}

function getIceGrd(key,centerX,centerY,radius,cold){
    const ctx = canvas[key].getContext("2d");
    const iceColor = ['#3f7eb3','#6ba7cc','#aedbf0','#fafeff','#e2fcff','#cbf1fa'];
    const ice= ctx.createLinearGradient(centerX,centerY+radius,centerX,centerY-radius,);
    for (let index = 0; index < iceColor.length; index++) {
        var coldFactor = (cold + index)/10;
        if (coldFactor>1){coldFactor =1}
        ice.addColorStop(coldFactor, iceColor[index]);
    }
    return ice;
}

function majorLabel(key,centerX,centerY,radius,color){
    const ctx = canvas[key].getContext("2d");
    //angle from midline
    const angle = 25;
    //left 
    const fontSize = 2*vw;
    const xLeft = centerX + Math.cos(Math.PI * (90+angle)/180) * radius - 0.5*fontSize;
    const yLeft = centerY + Math.sin(Math.PI * (90+angle)/180) * radius;
    ctx.beginPath();
    ctx.font = fontSize + 'px Quicksand';
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'right';ctx.fillStyle = color
    ctx.fillText('Sympathetic',xLeft-fontSize,yLeft);

    //right
    const xRight = centerX + Math.cos(Math.PI * (90-angle)/180) * radius + 0.5*fontSize;
    const yRight = centerY + Math.sin(Math.PI * (90-angle)/180) * radius;
    ctx.textAlign = 'left';
    ctx.fillText('Parasympathetic',xRight+fontSize,yRight);

    ctx.font = 0.7*fontSize + 'px Quicksand';
    ctx.textAlign = 'right';
    ctx.fillText('nervous system',xLeft-fontSize,yLeft+0.7*fontSize);
    ctx.textAlign = 'left';
    ctx.fillText('nervous system',xRight+fontSize,yRight+0.7*fontSize);
}

var bNo = 0;  
function next(no){
  n = Number(no);
  //check which box is in the view
  const box = document.getElementsByClassName('block');
  var i;
  for (i=0;i<box.length;i++){
    var top = box[i].getBoundingClientRect().top;
    if (top<window.innerHeight/2){
      bNo=i;
    }
  }

  if (n==1 || n==-1){
      bNo = n + bNo;
      if (bNo<0){
        window.scrollTo(0,0);bNo=-1;
      }
      if (bNo>=box.length){
        var end = document.getElementsByID('endPage')
        end[0].scrollIntoView({behavior:"smooth", block:"start"})
        bNo=box.length+1;
      }
    
      box[bNo].scrollIntoView({behavior:"smooth", block:"start"});
      //autoplay vdo on bNo3
      const sullyClip = document.getElementById('sully')
      const def = document.getElementById('defRefSyn');
      if (bNo==3){
        sullyClip.play();
        def.style.opacity = 0;
        def.style.visibility = 'visible';
        for (let index = 0; index <=1 ; index=index+0.1) {
            setTimeout(() => {
                def.style.opacity = index;                
            }, index*1000+3000);
           
        }
      } else {
        sullyClip.load();
        def.style.visibility = 'hidden';
      }
  }
} 

</script>
</body>
</html>